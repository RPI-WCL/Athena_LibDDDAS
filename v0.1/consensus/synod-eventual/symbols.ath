#****************************************************************************
# The symbols needed to express the Synod algorithm using the actor model 

# Lines beginning with '#+-' are used to create the hierarchy graph
#+- Symbols for Synod Specification 
#****************************************************************************

module Synod{

	#-- Actors
	domain Actor

	#-- Values that can be proposed
	domain Value
	declare nilV : Value
	declare equal-val : (Value) [Value Value] -> Value [=]

	#-- Ballot (not directly using natural numbers)
	domain Ballot 

	#-- Syntactic Sugar Predicate that returns true if the ballot satisfies P1+P2-True properties for progress
	declare P1+P2-True: (Ballot) [Ballot] -> Boolean	

	#-- Some basic relations over ballots (similar to natural numbers)
	declare less-than : (Ballot) [Ballot Ballot] -> Boolean [<]
	declare less-than-equal : (Ballot) [Ballot Ballot] -> Boolean [=<]
	declare greater-than : (Ballot) [Ballot Ballot] -> Boolean [>]
	declare greater-than-equal : (Ballot) [Ballot Ballot] -> Boolean [>=]
	declare equal : (Ballot) [Ballot Ballot] -> Boolean [=]

	#-- Predicates over the set of actors (creates two subests, one each for proposers and acceptors)
	declare prp: (Actor) [Actor] -> Boolean
	declare acc: (Actor) [Actor] -> Boolean

	#-- Syntactic Sugar Predicate that returns true if an actor satisfies the required nonfaulty behavior for progress 
	declare nonfaulty: (Actor) [Actor] -> Boolean

	#-- Set od all Non-empty Quorums
	datatype Quorum := Actor 
					| (consQ Quorum Actor)
	declare inQ : (Actor, Quorum) [Actor Quorum] -> Boolean

	#-- Message types
	domain Type

	#-- Messages
	datatype Message := (consM frm:Actor to:Actor typ:Type bal:Ballot val:Value)

	#-- Get functions for messages
	declare msgSndr: (Message) [Message] -> Actor
	declare msgRcpnt: (Message) [Message] -> Actor
	declare msgTyp: (Message) [Message] -> Actor
	declare msgBal: (Message) [Message] -> Actor
	declare msgVal: (Message) [Message] -> Actor

	#-- Set of messages
	datatype MessageSet := nilMSet 
						| (consMSet MessageSet Message)

	declare inMSet : (Message, MessageSet) [Message MessageSet] -> Boolean [in]

	#-- Actor Local State 
	datatype ALS := (consALS ms:MessageSet bal:Ballot bal':Ballot val':Value lck:Boolean)

	#-- Functions that return values from actor local state
	declare amu: (ALS) [ALS]-> MessageSet # set of messages received but not responded to yet 
	declare beta: (ALS) [ALS]-> Ballot    # highest ballot seen
	declare beta_cap: (ALS) [ALS]-> Ballot # highest ballot accepted
	declare value: (ALS) [ALS]-> Value    # value corresponding to beta_cap
	declare lock: (ALS) [ALS]-> Boolean  #
	declare init: (ALS) [ALS]-> Boolean # to store if it has initiated any ballot yet (used for livelock proof)
	declare has-promises : (ALS, Ballot, Quorum) [ALS Ballot Quorum]-> Boolean # returns true if it has received 1b from a quorum
	declare decide-value : (ALS) [ALS]-> Value # Selects the value to be proposed depending on values sent by quorum. Otherwise returns some new value.
	declare has-votes : (ALS, Ballot, Quorum) [ALS Ballot Quorum]-> Boolean #returns true if it has received 2b from a quorum
	declare sent2A : (ALS, Quorum, Ballot, Value) [ALS Ballot Value Quorum N]-> Boolean #proposer has sent 2A mssages to a quorum

	#-- Set of actors 
	datatype ActorSet := nilASet 
					| (consASet ActorSet Actor)

	declare inASet : (Actor, ActorSet) [Actor ActorSet] -> Boolean 

	#-- Domain Configuration
	domain Configuration

	#-- Functions that return the set of in-transit messages an actors local states in a configuration 
	declare mu : (Configuration) [Configuration] -> MessageSet # gets the multiset of messages "en route" 
	declare als: (Configuration, Actor) [Configuration Actor] -> ALS # gets actor local state from configuration 
	declare alpha: (Configuration) [Configuration] -> ActorSet # gets the mapping of available actors
	declare alpha_bar: (Configuration) [Configuration] -> ActorSet # gets the mapping of failed actors


	#-- Datatype of transition steps (create not needed for Synod proof)
	datatype Step := (receive a:Actor m:Message) 
	               | (send a:Actor m:Message) 
	               | (create old:Actor new:Actor)
	               | (stop a:Actor )
	               | (start a:Actor ) # "begin" keyword taken in Athena


	#-- Datatype of transition paths borrowed from Musser
	datatype TP := Initial 
	                     | (then TP Step)


	declare config :  [TP ] -> Configuration # last configuration in a given path
	declare ready-to : [TP  Actor Step] -> Boolean # if actor is ready to perform some step in the last configuration in a given path
	declare available :  [TP  Actor] -> Boolean # if actor is available in last configuration in a given path 


	#-- The following creates a sub-transition path upto the given index
	#-- used for accessing indexed positions in transition paths
	declare rho :  [TP  N] -> TP


	#-- Predicate that checks if a proposer has obtained 
	#-- votes from a quorum for a ballot (learnt of successful consensus)
	declare learn: (Actor, Configuration, Ballot) [Actor Configuration Ballot] -> Boolean


	#-- Declaring all constants and variables used in the rest of the proofs 
	#-- There are four types of messages
	declare 1a, 1b, 2a, 2b, failT : Type     

	# -- Set of variables used throughout module Synod
	define [p a x Q b bH b2 b3 v v2 v3 m m2 ms1 ms2 c s T i j k l y z w e f t u p2 a2 typ sender' recipient'] :=
																					 	        [   ?p:Actor 
																					 	        	?a:Actor 
																					 	        	?x:Actor 
																					 	        	?Q:Quorum 
																					 	        	?b:Ballot 
																					 	        	?bH:Ballot 
																					 	        	?b2:Ballot
																					 	        	?b3:Ballot
																					   	        	?v:Value
																					   	        	?v2:Value
																					   	        	?v3:Value 
																					   	        	?m:Message 
																					   	        	?m2:Message
																					   	        	?ms1:MessageSet 
																					   	        	?ms2:MessageSet 
																					   	        	?c:Configuration 
																					   	        	?s:Step
																					   	        	?T:TP 
																					   	        	?i:N 
																					   	        	?j:N 
																					   	        	?k:N
																					   	        	?l:N
																					   	        	?y:N
																					   	        	?z:N
																					   	        	?w:N
																					   	        	?e:N
																					   	        	?f:N
																					   	        	?t:N
																					   	        	?u:N
																					   	        	?p2:Actor
																					   	        	?a2:Actor
																					   	        	?typ:Type
																					   	        	?sender':Actor
																					   	        	?recipient':Actor  ]

}#close module Synod	